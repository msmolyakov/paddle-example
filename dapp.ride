{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let keyAccountPrefix = "@"
let keyPubKeyPrefix = "$"
let keyBase = "base"
let keyHeight = "height"
let keyLast = "last"
let keyUtx = "utx"
let keyUtxSize = "utx-size"

let dappPublicKey = base58'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM' # TODO выставить в конце!

let registrationCost = 5 # TODO 10?
let utxLimit = 10
let rude = 100 # TODO gaz = 1
let blockMinerReward = 10 * rude
let initBalance = 1 * rude

func h() = getIntegerValue(this, keyHeight)
func base() = getIntegerValue(this, keyBase)

func blockInfo(h: Int) = getStringValue(this, if h == -1 then keyLast else h.toString())
func blockReferenceHeight(h: Int) = {
    let blInfo = blockInfo(h)
    let left = extract(indexOf(blInfo, ",", extract(indexOf(blInfo, ",")) + 1)) + 1
    let right = extract(indexOf(blInfo, ",", left))
    take(drop(blInfo, left), right - left).parseIntValue()
}
func blockMinerPublicKey(h: Int) = {
    let blInfo = blockInfo(h)
    let left = extract(indexOf(blInfo, ",", extract(indexOf(blInfo, ",", extract(indexOf(blInfo, ",")) + 1)) + 1)) + 1
    let right = extract(indexOf(blInfo, ",", left))
    take(drop(blInfo, left), right - left)
}
func blockGazReward(h: Int) = {
    let blInfo = blockInfo(h)
    let left = extract(indexOf(blInfo, ",", extract(indexOf(blInfo, ",", extract(indexOf(blInfo, ",", extract(indexOf(blInfo, ",", extract(indexOf(blInfo, ",")) + 1)) + 1)) + 1)) + 1)) + 1
    let right = extract(indexOf(blInfo, ",", left))
    take(drop(blInfo, left), right - left)
}

func pubKey(pk: ByteVector) = pk.toBase58String()
func accountOf(pk: ByteVector) = getString(this, keyPubKeyPrefix + pubKey(pk))
func accountInfo(name: String) = getString(this, keyAccountPrefix + name)
func isRegistered(pK: ByteVector) = isDefined(accountOf(pK))
func isTaken(acc: String) = isDefined(accountInfo(acc))

func pubKeyOf(account: String) = {
    let accInfo = extract(accountInfo(account))
    let left = 0
    let right = extract(indexOf(accInfo, ",", left))
    take(drop(accInfo, left), right - left)
}
func regHeightOf(account: String) = {
    let accInfo = extract(accountInfo(account))
    let left = extract(indexOf(accInfo, ",")) + 1
    let right = extract(indexOf(accInfo, ",", left))
    take(drop(accInfo, left), right - left).parseIntValue()
}
func totalBalanceOf(account: String) = {
    let accInfo = extract(accountInfo(account))
    let left = extract(indexOf(accInfo, ",", extract(indexOf(accInfo, ",")) + 1)) + 1
    let right = extract(indexOf(accInfo, ",", left))
    take(drop(accInfo, left), right - left).parseIntValue()
}
func availableBalanceOf(account: String) = {
    let accInfo = extract(accountInfo(account))
    let left = extract(indexOf(accInfo, ",", extract(indexOf(accInfo, ",", extract(indexOf(accInfo, ",")) + 1)) + 1)) + 1
    let right = accInfo.size()
    take(drop(accInfo, left), right - left).parseIntValue()
}

func validate(script: String) = {
    let words = script.split(" ") # TODO разделитель для команд
    func send(recipient: String, amount: Int) = {
        if amount < 1 then "amount " + amount.toString() + " must be a positive number"
        else if !isTaken(recipient) then "recipient '" + recipient + "' doesn't exist"
        else ""
    }

    if words.size() < 3 then "unknown script format" # TODO 3? 2? 4?
    else
        if words[0] == "send" then
            send(words[1], words[2].parseIntValue())
        # TODO atomic swap
        # TODO lightning
        else
            "script starts from unknown command"
}

func estimate(script: String) = {
    let words = script.split(" ")
    if words[0] == "send" then 1 # TODO может быть 5 операций - сендов или других
    # TODO atomic swap
    # TODO lightning
    # TODO NFT
    else 0
}

func evaluate(gas: Int, script: String) = {
    let words = script.split(" ")
    func send(recipient: String, amount: Int) = {
        "send" # TODO проверить баланс
    }
    #func lightning() = {"lightning"} # TODO работа с лайтнинг каналом
    #func swap() = {"swap"} # TODO работа с atomic swap

    if words[0] == "send" then
        send(words[1], words[2].parseIntValue())
    else WriteSet([]) # недостижимое состояние
}

func pErr(msg: String) = throw("Parse error: " + msg + "!")

#TODO del
@Callable(i)
func unitTest() = {
    #let accName = "bob1"
    #WriteSet([
    #    DataEntry("pK", pubKeyOf(accName)),
    #    DataEntry("hei", regHeightOf(accName)),
    #    DataEntry("tB", totalBalanceOf(accName)),
    #    DataEntry("aB", availableBalanceOf(accName))
    #])

    WriteSet([DataEntry("genRefH", blockReferenceHeight(-1)), DataEntry("genMinerK", blockMinerPublicKey(-1))])
}

@Callable(i)
func genesis() = {
    if i.caller != this then
        throw("blockchain can be created only by the dApp")
    else if isDefined(getString(this, keyLast))
        || isDefined(getInteger(this, keyHeight))
        || isDefined(getInteger(this, keyBase))
        || isDefined(getInteger(this, keyUtx))
        || isDefined(getInteger(this, keyUtxSize))
    then
        throw("blockchain is already created")
    else
        let gHeight = 0
        # blockHash (omitted here), height, ref height, miner pK, prevBlockHash, gaz used in txs, txs (omitted here)
        let genesisBlock = "," + gHeight.toString() + "," + height.toString() + "," + toBase58String(i.callerPublicKey) + ",0,0,"
        WriteSet(
            DataEntry(keyLast, genesisBlock)
            ::DataEntry(keyHeight, gHeight)
            ::DataEntry(keyBase, 1)
            ::DataEntry(keyUtx, "")
            ::DataEntry(keyUtxSize, 0)
            ::nil
        )
}

# TODO может рега только за майнинг блока?
@Callable(i)
func register(name: String) = {
    let callerPubKey = i.callerPublicKey.toBase58String()
    let validChars = "abcdefghijklmnopqrstuvwxyz0123456789"

    if (!isDefined(i.payment) || isDefined(extract(i.payment).assetId) || extract(i.payment).amount != registrationCost * 100000000) then
        throw("Registration costs " + registrationCost.toString() + " Waves!")
    else if !(size(name) > 0 && size(name) <= 8 && isDefined(indexOf(validChars, take(name, 1)))
        && (if (size(name) > 1) then isDefined(indexOf(validChars, take(drop(name, 1), 1))) else true)
        && (if (size(name) > 2) then isDefined(indexOf(validChars, take(drop(name, 2), 1))) else true)
        && (if (size(name) > 3) then isDefined(indexOf(validChars, take(drop(name, 3), 1))) else true)
        && (if (size(name) > 4) then isDefined(indexOf(validChars, take(drop(name, 4), 1))) else true)
        && (if (size(name) > 5) then isDefined(indexOf(validChars, take(drop(name, 5), 1))) else true)
        && (if (size(name) > 6) then isDefined(indexOf(validChars, take(drop(name, 6), 1))) else true)
        && (if (size(name) > 7) then isDefined(indexOf(validChars, take(drop(name, 7), 1))) else true))
    then
        throw("Account name must have [1..8] length and contain only [a-z0-9] chars")
    else if isRegistered(i.callerPublicKey) then
        throw("Public key of the caller is already registered as '" + extract(accountOf(i.callerPublicKey)) + "'")
    else if isTaken(name) then
        throw("Account name '" + name + "' is already taken")
    else
        WriteSet([
            DataEntry(keyPubKeyPrefix + i.callerPublicKey.toBase58String(), name),
            #publicKey, regHeight, totalBalance, availableBalance
            DataEntry(keyAccountPrefix + name, pubKey(i.callerPublicKey) + "," + h().toString() + "," + initBalance.toString() + "," + initBalance.toString())
        ])
}

# TODO плавно снижать награду за блок, чтобы через N блоков осталась только комиссия за транзы
# TODO нельзя майнить на той же высоте, что и текущий блок
@Callable(i)
func mine() = {
    # TODO для пазла должен быть нонс
    let freq = 2 # TODO заменить на проверку выполнения пазла (кол-во нулей или что-то еще) с учетом текущей сложности

    # TODO майнер должен быть зареган
    if i.caller == this then
        throw("The dApp can't mine!")
    else if height - blockReferenceHeight(-1) < freq then
        throw("Can't mine more often than once every " + freq.toString() + " waves blocks")
    else
        let nextHeight = h() + 1
        let liquidBlock = blockInfo(-1) # TODO брать хэш только от значений, без запятых?
        let liquidBlockHash = sha256(liquidBlock.toBytes()).toBase58String() # TODO Utf8 или toBase58? достаточно ли sha256? Попробовать blake и keccak

        ScriptResult(
            WriteSet([
                DataEntry(h().toString(), liquidBlockHash + liquidBlock)
                , DataEntry(keyHeight, nextHeight)
                , DataEntry(keyBase, base() + 1) # TODO калибровать сложность (от высоты, на которой был смайнен прошлый блок). Какая скорость?
                , DataEntry(keyLast, "," + nextHeight.toString() + "," + height.toString() + "," + toBase58String(i.callerPublicKey))
            ]),
            TransferSet([]) # TODO отправить комиссии за прошлый блок прошлому майнеру и dApp.
        )
}

# TODO ПРОВЕРЯТЬ БАЛАНС И SEND!
# TODO учитывать в availableBalance газ в UTX, средства в свопе и лайтнинге
@Callable(i)
func utxProcessing() = {
    if i.callerPublicKey != blockMinerPublicKey(-1).fromBase58String() then
        throw("Only the current miner can processing UTX!")
    else if getIntegerValue(this, keyUtxSize) == 0 then
        WriteSet([]) # чтобы InvokeScript успешно прошел и за спам транзакции пришлось платить
    else
        let utx = getStringValue(this, keyUtx)
        let marker = extract(indexOf(utx, ";"))
        let tx = take(utx, marker - 1)

        let txSignature = take(tx, extract(indexOf(tx, ",")))
        let txSenderPublicKey = { let raw = drop(tx, txSignature.size() + 1); take(raw, extract(indexOf(raw, ","))) }
        let txGas = { let raw = drop(tx, txSignature.size() + txSenderPublicKey.size() + 2); take(raw, extract(indexOf(raw, ","))) }
        let txScript = drop(tx, txSignature.size() + txSenderPublicKey.size() + txGas.size() + 3)

        # TODO evaluate!

        WriteSet([DataEntry("a", "a")]) # TODO verify (наличие газа), evaluate, запомнить gas, положить tx в блок
        # TODO если транзакции кончились или достигнут лимит транзакций за раз, то подтереть UTX и уменьшить size
}

@Callable(i)
func transaction(signatureBase64: String, gas: Int, script: String) = {
    if i.caller == this then
        throw("The dApp can't send transactions!")
    else if !isRegistered(i.callerPublicKey) then
        throw("Only registered accounts can send transactions!")
    else if !(getIntegerValue(this, keyUtxSize) < utxLimit) then
        throw("UTX size limit reached! Please try later")
    else
        let txBody = extract(accountOf(i.callerPublicKey)) + "," + gas.toString() + "," + script
        let message = validate(script) # TODO ПРОВЕРЯТЬ БАЛАНС И SEND!

        if !sigVerify(txBody.toBytes(), signatureBase64.fromBase64String(), i.callerPublicKey) then
            throw("Incorrect signature!")
        else if message.size() > 0 then pErr(message)
        else if !(gas > 0) then
            throw("Gas amount must be positive!")
        else if availableBalanceOf(extract(accountOf(i.callerPublicKey))) < gas then
            throw("Not enough balance for payment")
        else
            let gasRequired = estimate(script)
            if gas < gasRequired then
                throw("Not enough gas: actual " + gas.toString() + " but " + gasRequired.toString() + " estimated")
        else
            let utxPool = getStringValue(this, keyUtx)
            WriteSet([
                DataEntry(keyUtx, utxPool + signatureBase64 + "," + txBody + ";"),
                DataEntry(keyUtxSize, getIntegerValue(this, keyUtxSize) + 1)
                # TODO availBalance -= gaz
            ])
}

@Verifier(tx)
func verify() = {
    #match tx {
    #    case d:DataTransaction => false # blockchain can be changed only via dApp actions
    #    case t:TransferTransaction => !isDefined(t.assetId) # TODO ведь так проверять на вавесность?
    #    # TODO для SetScript - мультисиг с китами в блокчейне
    #    case _ => sigVerify(tx.bodyBytes, tx.proofs[0], dappPublicKey)
    #}
    true
}
