{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# TODO client:
# balances
# sign & send tx
# utx view
# blocks list (+ hide empty)
# block view (+ txs list)
# tx view
# account view
# курс на DEX (тикер!)

# TODO miner:
# provide seed
# monitor height => recalculate base and restart mining thread on new
# calculate zero bytes
# show rewards and balance

# TODO dApp:
# gateway
# NFT
# lightning
# multiple commands
# fixed point

let keyAccountPrefix = "@"
let keyPubKeyPrefix = "$"
let keyHeight = "height"
let keyLast = "last"
let keyUtx = "utx"
let keyUtxSize = "utx-size"

let dappPublicKey = base58'' # TODO SET!

let registrationCost = 5
let utxLimit = 100
let blockMinerReward = 20
let initBalance = 5

func h() = getIntegerValue(this, keyHeight)

func blockInfo(h: Int) = getStringValue(this, if h == -1 || h == h() then keyLast else h.toString())
func blockHeaders(h: Int) = blockInfo(h).split(";")[0].split(",")

func blockHash(h: Int) = blockHeaders(h)[0]
func blockTimestamp(h: Int) = blockHeaders(h)[1].parseIntValue()
func blockReferenceHeight(h: Int) = blockHeaders(h)[2].parseIntValue()
func blockMinerPublicKey(h: Int) = blockHeaders(h)[3] # TODO account?
func blockNonce(h: Int) = blockHeaders(h)[4].parseIntValue()
func blockPrevHash(h: Int) = blockHeaders(h)[5]
func blockDifficulty(h: Int) = blockHeaders(h)[6].parseIntValue()
func blockGasReward(h: Int) = blockHeaders(h)[7].parseIntValue()
func blockTxs(h: Int) = {
    let blInfo = blockInfo(h)
    let semicolon = indexOf(blInfo, ";")
    if isDefined(semicolon) then
        drop(blInfo, extract(semicolon) + 1)
    else ""
}

func pubKey(pk: ByteVector) = pk.toBase58String()
func isRegistered(pK: ByteVector) = isDefined(getString(this, keyPubKeyPrefix + pubKey(pK)))
func isTaken(name: String) = isDefined(getString(this, keyAccountPrefix + name))
func accountOf(pK: ByteVector) = getStringValue(this, keyPubKeyPrefix + pubKey(pK))
func accountInfo(name: String) = getStringValue(this, keyAccountPrefix + name).split(",")

func pubKeyOf(account: String) = accountInfo(account)[0]
func regHeightOf(account: String) = accountInfo(account)[1].parseIntValue()
func totalBalanceOf(account: String) = accountInfo(account)[2].parseIntValue()
func availableBalanceOf(account: String) = accountInfo(account)[3].parseIntValue()

func estimate(script: String) = {
    let words = script.split(" ")

    if words[0] == "SEND" then
        let gasRequired = 1
        let amount = words[2].parseIntValue()
        [gasRequired, amount]
    else [1000000, 0] # unreachable state because validated
}

func evaluate(script: String) = {
    let words = script.split(" ")
    func send(recipient: String, amount: Int) = {
        DataEntry(keyAccountPrefix + recipient, pubKeyOf(recipient) + "," + regHeightOf(recipient).toString() + "," 
            + (totalBalanceOf(recipient) + amount).toString() + "," + (availableBalanceOf(recipient) + amount).toString())
    }

    if words[0] == "SEND" then
        send(words[1], words[2].parseIntValue())
    else throw("can't evaluate script") # unreachable state because validated
}

# TODO несколько команд!
func validate(acc: String, gas: Int, script: String, checkBalance: Boolean) = {
    let words = script.split(" ")

    if words[0] == "SEND" then
        if words.size() != 3 then "SEND command expects args: recipient amount"
        else
            let gasRequired = estimate(script)[0]
            let recipient = words[1]
            let amount = words[2].parseIntValue()

            if !isTaken(recipient) then "recipient '" + recipient + "' doesn't exist"
            else if recipient == acc then "sender can't do SEND to itself"
            else if amount < 1 then "amount " + amount.toString() + " must be a positive number"
            else if !(gas > 0) then "Gas amount must be positive!"
            else if gas < gasRequired then "Not enough gas: actual " + gas.toString() + " but " + gasRequired.toString() + " estimated"
            else if checkBalance && availableBalanceOf(acc) < gas + amount then "Not enough available balance for payment and gas"
            else ""
    else
        "unknown command " + words[0]
}

@Callable(i)
func genesis() = {
    if i.caller != this then
        throw("Rudechain can be created only by the dApp")
    else if isDefined(getString(this, keyLast))
        || isDefined(getInteger(this, keyHeight))
        || isDefined(getInteger(this, keyUtx))
        || isDefined(getInteger(this, keyUtxSize))
    then
        throw("Rudechain is already created")
    else
        let gHeight = 0
        let genesisBlock = "0," + lastBlock.timestamp.toString() + "," + gHeight.toString() + "," + toBase58String(i.callerPublicKey) + ",0,0,0"
        WriteSet([
            DataEntry(keyLast, genesisBlock),
            DataEntry(keyHeight, gHeight),
            DataEntry(keyUtx, ""),
            DataEntry(keyUtxSize, 0)
        ])
}

@Callable(i)
func register(name: String) = {
    let callerPubKey = i.callerPublicKey.toBase58String()
    let validChars = "abcdefghijklmnopqrstuvwxyz0123456789"

    if (!isDefined(i.payment) || isDefined(extract(i.payment).assetId) || extract(i.payment).amount != registrationCost * 100000000) then
        throw("Registration costs " + registrationCost.toString() + " Waves!")
    else if !(size(name) > 0 && size(name) <= 8 && isDefined(indexOf(validChars, take(name, 1)))
        && (if (size(name) > 1) then isDefined(indexOf(validChars, take(drop(name, 1), 1))) else true)
        && (if (size(name) > 2) then isDefined(indexOf(validChars, take(drop(name, 2), 1))) else true)
        && (if (size(name) > 3) then isDefined(indexOf(validChars, take(drop(name, 3), 1))) else true)
        && (if (size(name) > 4) then isDefined(indexOf(validChars, take(drop(name, 4), 1))) else true)
        && (if (size(name) > 5) then isDefined(indexOf(validChars, take(drop(name, 5), 1))) else true)
        && (if (size(name) > 6) then isDefined(indexOf(validChars, take(drop(name, 6), 1))) else true)
        && (if (size(name) > 7) then isDefined(indexOf(validChars, take(drop(name, 7), 1))) else true))
    then
        throw("Account name must have [1..8] length and contain only [a-z0-9] chars")
    else if isRegistered(i.callerPublicKey) then
        throw("Public key of the caller is already registered as '" + accountOf(i.callerPublicKey) + "'")
    else if isTaken(name) then
        throw("Account name '" + name + "' is already taken")
    else
        WriteSet([
            DataEntry(keyPubKeyPrefix + i.callerPublicKey.toBase58String(), name),
            DataEntry(keyAccountPrefix + name, pubKey(i.callerPublicKey) + "," + h().toString() + "," + initBalance.toString() + "," + initBalance.toString())
        ])
}

# TODO везде не доверять caller.publicKey - проверять подпись
# TODO плавно снижать до 0 награду за блок и увеличивать % от газа до 100, чтобы через N блоков осталась только комиссия за транзы
# TODO вместо available хранить reserved?
# TODO везде хранить не паблик кеи, а аккаунты
@Callable(i)
func mine(nonce: Int) = {
    let delta = lastBlock.height - blockReferenceHeight(-1)
    let difficulty = blockDifficulty(-1)
    let newDifficulty = if delta == 1 then difficulty + 2 else if delta == 2 || delta == 3 || difficulty == 1 then difficulty else difficulty - 1

    let hash = blake2b256((
        lastBlock.timestamp.toString()
        + lastBlock.height.toString()
        + i.callerPublicKey.toBase58String()
        + nonce.toString()
        + blockPrevHash(-1)
    ).toBytes())

    let byte0LeadingZeros = getIntegerValue(Alias("zerobytes"), toBase58String(take(hash, 1)))
    let byte1LeadingZeros = getIntegerValue(Alias("zerobytes"), toBase58String(takeRight(take(hash, 2), 1)))
    let byte2LeadingZeros = getIntegerValue(Alias("zerobytes"), toBase58String(takeRight(take(hash, 3), 1)))
    let byte3LeadingZeros = getIntegerValue(Alias("zerobytes"), toBase58String(takeRight(take(hash, 4), 1)))
    let byte4LeadingZeros = getIntegerValue(Alias("zerobytes"), toBase58String(takeRight(take(hash, 5), 1)))
    let byte5LeadingZeros = getIntegerValue(Alias("zerobytes"), toBase58String(takeRight(take(hash, 6), 1)))
    let byte6LeadingZeros = getIntegerValue(Alias("zerobytes"), toBase58String(takeRight(take(hash, 7), 1)))
    let byte7LeadingZeros = getIntegerValue(Alias("zerobytes"), toBase58String(takeRight(take(hash, 8), 1)))

    let firstZeroBits = if byte0LeadingZeros != 8 then byte0LeadingZeros else ( 8 +
                        if byte1LeadingZeros != 8 then byte1LeadingZeros else ( 8 +
                        if byte2LeadingZeros != 8 then byte2LeadingZeros else ( 8 +
                        if byte3LeadingZeros != 8 then byte3LeadingZeros else ( 8 +
                        if byte4LeadingZeros != 8 then byte4LeadingZeros else ( 8 +
                        if byte5LeadingZeros != 8 then byte5LeadingZeros else ( 8 +
                        if byte6LeadingZeros != 8 then byte6LeadingZeros else ( 8 + 
                                                        byte7LeadingZeros)))))))

    if i.caller == this then throw("The dApp can't mine!")
    else if !isRegistered(i.callerPublicKey) then throw("Miner must be registered!")
    else if delta == 0 then throw("Can't mine on same reference height as last block: " + lastBlock.height.toString())
    else if firstZeroBits < newDifficulty then throw("Hash has " + firstZeroBits.toString() + " difficulty but " + newDifficulty.toString() + " required")
    else
        let prevMinerAccount = blockMinerPublicKey(-1)
        let newMinerAccount = accountOf(i.callerPublicKey)
        let newHeight = h() + 1
        let newBlock = hash.toBase58String()
            + "," + lastBlock.timestamp.toString() 
            + "," + lastBlock.height.toString() 
            + "," + i.callerPublicKey.toBase58String() 
            + "," + nonce.toString() 
            + "," + blockPrevHash(-1)
            + "," + newDifficulty.toString()
            + ",0"

        WriteSet([
            DataEntry(keyHeight, newHeight),
            DataEntry(keyAccountPrefix + prevMinerAccount, pubKeyOf(prevMinerAccount) + "," + regHeightOf(prevMinerAccount).toString() + "," 
                + (totalBalanceOf(prevMinerAccount) + blockGasReward(-1)).toString() + "," + (availableBalanceOf(prevMinerAccount) + blockGasReward(-1)).toString()),
            DataEntry(h().toString(), blockInfo(-1)),
            DataEntry(keyAccountPrefix + newMinerAccount, pubKeyOf(newMinerAccount) + "," + regHeightOf(newMinerAccount).toString() + "," 
                + (totalBalanceOf(newMinerAccount) + blockMinerReward).toString() + "," + (availableBalanceOf(newMinerAccount) + blockMinerReward).toString()),
            DataEntry(keyLast, newBlock)
        ])
}

@Callable(i)
func utxProcessing() = {
    if i.callerPublicKey != blockMinerPublicKey(-1).fromBase58String() then throw("Only the current miner can processing UTX!")
    else if getIntegerValue(this, keyUtxSize) == 0 then WriteSet([])
    else
        let utx = getStringValue(this, keyUtx)
        let utxSize = getIntegerValue(this, keyUtxSize)
        let marker = extract(indexOf(utx, ";"))
        let tx = take(utx, marker)

        let txSignature = take(tx, extract(indexOf(tx, ",")))
        let txSenderPublicKey = { let raw = drop(tx, txSignature.size() + 1); take(raw, extract(indexOf(raw, ","))) }
        let txGas = { let raw = drop(tx, txSignature.size() + txSenderPublicKey.size() + 2); take(raw, extract(indexOf(raw, ","))) }
        let txScript = drop(tx, txSignature.size() + txSenderPublicKey.size() + txGas.size() + 3)

        let txSenderAcc = accountOf(txSenderPublicKey.toBytes())
        let validation = validate(txSenderAcc, txGas.parseIntValue(), txScript, false)
        let costs = estimate(txScript)

        if validation.size() > 0 then 
            WriteSet([DataEntry(keyUtxSize, utxSize - 1), DataEntry(keyUtx, drop(utx, marker + 1))])
        else
            let increasedReward = blockGasReward(-1) + costs[0]
            let txs = if isDefined(blockInfo(-1).indexOf(";")) then ";" + blockTxs(-1) else ""
            WriteSet(
                DataEntry(keyLast, blockHash(-1) + "," + blockTimestamp(-1).toString() + "," + blockReferenceHeight(-1).toString() + "," + blockMinerPublicKey(-1) + "," 
                    + blockNonce(-1).toString() + "," + blockPrevHash(-1) + "," + blockDifficulty(-1).toString() + "," + increasedReward.toString() + txs + ";" + tx)
                ::DataEntry(keyUtxSize, utxSize - 1)
                ::DataEntry(keyUtx, drop(utx, marker + 1))
                ::evaluate(txScript)
                ::DataEntry( keyAccountPrefix + txSenderAcc, txSenderPublicKey + "," + regHeightOf(txSenderAcc).toString() + "," 
                    + (totalBalanceOf(txSenderAcc) - costs[0] - costs[1]).toString() + "," 
                    + (availableBalanceOf(txSenderAcc) + txGas.parseIntValue() - costs[0]).toString() )
                ::nil
            )
}

@Callable(i)
func transaction(signatureBase64: String, gas: Int, script: String) = {
    if i.caller == this then throw("The dApp can't send transactions!")
    else if !isRegistered(i.callerPublicKey) then throw("Only registered accounts can send transactions!")
    else if !(getIntegerValue(this, keyUtxSize) < utxLimit) then throw("UTX size limit reached! Please try later")
    else
        let txBody = accountOf(i.callerPublicKey) + "," + gas.toString() + "," + script
        let acc = accountOf(i.callerPublicKey)
        let validation = validate(acc, gas, script, true)
        let costs = estimate(script)
        let reserved = costs[0] + costs[1]

        if validation.size() > 0 then throw(validation)
        else if !sigVerify(txBody.toBytes(), signatureBase64.fromBase64String(), i.callerPublicKey) then throw("Incorrect signature!")
        else
            let utxPool = getStringValue(this, keyUtx)
            WriteSet([
                DataEntry(keyUtx, utxPool + signatureBase64 + "," + txBody + ";"),
                DataEntry(keyUtxSize, getIntegerValue(this, keyUtxSize) + 1),
                DataEntry(keyAccountPrefix + acc, pubKeyOf(acc) + "," + regHeightOf(acc).toString() + "," + totalBalanceOf(acc).toString() + "," 
                    + (availableBalanceOf(acc) - reserved).toString())
            ])
}

@Verifier(tx)
func verify() = {
    match tx {
        case d:DataTransaction => false # rudechain can be changed only via dApp actions
        case _ => sigVerify(tx.bodyBytes, tx.proofs[0], dappPublicKey)
    }
}
