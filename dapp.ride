{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# TODO client:
# sign & send tx
# utx view
# blocks list (+ hide empty)
# block view (+ txs list)
# tx view
# account view
# курс на DEX

# TODO miner:
# provide seed
# monitor base and height => restart mining thread on new
# calculate zero bytes
# show rewards and balance

# TODO dApp:
# gateway
# NFT
# lightning
# multiple commands

let keyAccountPrefix = "@"
let keyPubKeyPrefix = "$"
let keyBase = "base"
let keyHeight = "height"
let keyLast = "last"
let keyUtx = "utx"
let keyUtxSize = "utx-size"

let dappPublicKey = base58'5AzfA9UfpWVYiwFwvdr77k6LWupSTGLb14b24oVdEpMM' # TODO выставить в конце!

let registrationCost = 5
let utxLimit = 100
let blockMinerReward = 20
let initBalance = 5

func h() = getIntegerValue(this, keyHeight)
func base() = getIntegerValue(this, keyBase)

func blockInfo(h: Int) = getStringValue(this, if h == -1 || h == h() then keyLast else h.toString())
func blockReferenceHeight(h: Int) = {
    let blInfo = blockInfo(h)
    let left = extract(indexOf(blInfo, ",", extract(indexOf(blInfo, ",")) + 1)) + 1
    let right = extract(indexOf(blInfo, ",", left))
    take(drop(blInfo, left), right - left).parseIntValue()
}
func blockMinerPublicKey(h: Int) = {
    let blInfo = blockInfo(h)
    let left = extract(indexOf(blInfo, ",", extract(indexOf(blInfo, ",", extract(indexOf(blInfo, ",")) + 1)) + 1)) + 1
    let right = extract(indexOf(blInfo, ",", left))
    take(drop(blInfo, left), right - left)
}
func blockPrevHash(h: Int) = {
    let blInfo = blockInfo(h)
    let left = extract(indexOf(blInfo, ",", extract(indexOf(blInfo, ",", extract(indexOf(blInfo, ",", extract(indexOf(blInfo, ",")) + 1)) + 1)) + 1)) + 1
    let right = extract(indexOf(blInfo, ",", left))
    take(drop(blInfo, left), right - left)
}
func blockGasReward(h: Int) = {
    let blInfo = blockInfo(h)
    let left = extract(indexOf(blInfo, ",", extract(indexOf(blInfo, ",", extract(indexOf(blInfo, ",", extract(indexOf(blInfo, ",", extract(indexOf(blInfo, ",")) + 1)) + 1)) + 1)) + 1)) + 1
    let right = extract(indexOf(blInfo, ",", left))
    take(drop(blInfo, left), right - left).parseIntValue()
}
func blockTxs(h: Int) = {
    let blInfo = blockInfo(h)
    let semicolon = indexOf(blInfo, ";")
    if isDefined(semicolon) then
        drop(blInfo, extract(semicolon) + 1)
    else ""
}

func pubKey(pk: ByteVector) = pk.toBase58String()
func accountOf(pk: ByteVector) = getString(this, keyPubKeyPrefix + pubKey(pk))
func accountInfo(name: String) = getString(this, keyAccountPrefix + name)
func isRegistered(pK: ByteVector) = isDefined(accountOf(pK))
func isTaken(acc: String) = isDefined(accountInfo(acc))

func pubKeyOf(account: String) = {
    let accInfo = extract(accountInfo(account))
    let right = extract(indexOf(accInfo, ","))
    take(accInfo, right)
}
func regHeightOf(account: String) = {
    let accInfo = extract(accountInfo(account))
    let left = extract(indexOf(accInfo, ",")) + 1
    let right = extract(indexOf(accInfo, ",", left))
    take(drop(accInfo, left), right - left).parseIntValue()
}
func totalBalanceOf(account: String) = {
    let accInfo = extract(accountInfo(account))
    let left = extract(indexOf(accInfo, ",", extract(indexOf(accInfo, ",")) + 1)) + 1
    let right = extract(indexOf(accInfo, ",", left))
    take(drop(accInfo, left), right - left).parseIntValue()
}
func availableBalanceOf(account: String) = {
    let accInfo = extract(accountInfo(account))
    let left = extract(indexOf(accInfo, ",", extract(indexOf(accInfo, ",", extract(indexOf(accInfo, ",")) + 1)) + 1)) + 1
    let right = accInfo.size()
    take(drop(accInfo, left), right - left).parseIntValue()
}

func estimate(script: String) = {
    let words = script.split(" ")

    if words[0] == "SEND" then
        let gasRequired = 1
        let amount = words[2].parseIntValue()
        [gasRequired, amount]
    else [1000000, 0] # unreachable state because validated
}

func evaluate(script: String) = {
    let words = script.split(" ")
    func send(recipient: String, amount: Int) = {
        DataEntry(keyAccountPrefix + recipient, pubKeyOf(recipient) + "," + regHeightOf(recipient).toString() + "," 
            + (totalBalanceOf(recipient) + amount).toString() + "," + (availableBalanceOf(recipient) + amount).toString())
    }

    if words[0] == "SEND" then
        send(words[1], words[2].parseIntValue())
    else throw("can't evaluate script") # unreachable state because validated
}

# TODO несколько команд!
func validate(acc: String, gas: Int, script: String, checkBalance: Boolean) = {
    let words = script.split(" ")

    if words[0] == "SEND" then
        if words.size() != 3 then "SEND command expects args: recipient amount"
        else
            let gasRequired = estimate(script)[0]
            let recipient = words[1]
            let amount = words[2].parseIntValue()

            if !isTaken(recipient) then "recipient '" + recipient + "' doesn't exist"
            else if recipient == acc then "sender can't do SEND to itself"
            else if amount < 1 then "amount " + amount.toString() + " must be a positive number"
            else if !(gas > 0) then "Gas amount must be positive!"
            else if gas < gasRequired then "Not enough gas: actual " + gas.toString() + " but " + gasRequired.toString() + " estimated"
            else if checkBalance && availableBalanceOf(acc) < gas + amount then "Not enough available balance for payment and gas"
            else ""
    else
        "unknown command " + words[0]
}

#TODO del
@Callable(i)
func unitTest() = {
    #let accName = "bob1"
    #WriteSet([
    #    DataEntry("pK", pubKeyOf(accName)),
    #    DataEntry("hei", regHeightOf(accName)),
    #    DataEntry("tB", totalBalanceOf(accName)),
    #    DataEntry("aB", availableBalanceOf(accName))
    #])

    WriteSet([DataEntry("genRefH", blockReferenceHeight(-1)), DataEntry("genMinerK", blockMinerPublicKey(-1))])
}

@Callable(i)
func genesis() = {
    if i.caller != this then
        throw("blockchain can be created only by the dApp")
    else if isDefined(getString(this, keyLast))
        || isDefined(getInteger(this, keyHeight))
        || isDefined(getInteger(this, keyBase))
        || isDefined(getInteger(this, keyUtx))
        || isDefined(getInteger(this, keyUtxSize))
    then
        throw("blockchain is already created")
    else
        let gHeight = 0
        # blockHash (omitted here), height, ref height, miner pK, prevBlockHash, gaz used in txs, txs (omitted here)
        let genesisBlock = "," + gHeight.toString() + "," + height.toString() + "," + toBase58String(i.callerPublicKey) + ",0,0"
        WriteSet(
            DataEntry(keyLast, genesisBlock)
            ::DataEntry(keyHeight, gHeight)
            ::DataEntry(keyBase, 1)
            ::DataEntry(keyUtx, "")
            ::DataEntry(keyUtxSize, 0)
            ::nil
        )
}

@Callable(i)
func register(name: String) = {
    let callerPubKey = i.callerPublicKey.toBase58String()
    let validChars = "abcdefghijklmnopqrstuvwxyz0123456789"

    if (!isDefined(i.payment) || isDefined(extract(i.payment).assetId) || extract(i.payment).amount != registrationCost * 100000000) then
        throw("Registration costs " + registrationCost.toString() + " Waves!")
    else if !(size(name) > 0 && size(name) <= 8 && isDefined(indexOf(validChars, take(name, 1)))
        && (if (size(name) > 1) then isDefined(indexOf(validChars, take(drop(name, 1), 1))) else true)
        && (if (size(name) > 2) then isDefined(indexOf(validChars, take(drop(name, 2), 1))) else true)
        && (if (size(name) > 3) then isDefined(indexOf(validChars, take(drop(name, 3), 1))) else true)
        && (if (size(name) > 4) then isDefined(indexOf(validChars, take(drop(name, 4), 1))) else true)
        && (if (size(name) > 5) then isDefined(indexOf(validChars, take(drop(name, 5), 1))) else true)
        && (if (size(name) > 6) then isDefined(indexOf(validChars, take(drop(name, 6), 1))) else true)
        && (if (size(name) > 7) then isDefined(indexOf(validChars, take(drop(name, 7), 1))) else true))
    then
        throw("Account name must have [1..8] length and contain only [a-z0-9] chars")
    else if isRegistered(i.callerPublicKey) then
        throw("Public key of the caller is already registered as '" + extract(accountOf(i.callerPublicKey)) + "'")
    else if isTaken(name) then
        throw("Account name '" + name + "' is already taken")
    else
        WriteSet([
            DataEntry(keyPubKeyPrefix + i.callerPublicKey.toBase58String(), name),
            #publicKey, regHeight, totalBalance, availableBalance
            DataEntry(keyAccountPrefix + name, pubKey(i.callerPublicKey) + "," + h().toString() + "," + initBalance.toString() + "," + initBalance.toString())
        ])
}

# TODO везде не доверять caller.publicKey - проверять подпись
# TODO плавно снижать до 0 награду за блок и увеличивать % от газа до 100, чтобы через N блоков осталась только комиссия за транзы
@Callable(i)
func mine() = {
    # TODO для пазла должен быть нонс
    let freq = 2 # TODO заменить на проверку выполнения пазла (кол-во нулей или что-то еще) с учетом текущей сложности

    if i.caller == this then throw("The dApp can't mine!")
    else if !isRegistered(i.callerPublicKey) then throw("Miner must be registered!")
    else if height - blockReferenceHeight(-1) < freq then throw("Can't mine more often than once every " + freq.toString() + " waves blocks") # TODO проверять пазл на base
    else
        let minerAccount = extract(accountOf(i.callerPublicKey))
        let nextHeight = h() + 1
        let liquidBlock = h().toString() + blockReferenceHeight(-1).toString() + blockMinerPublicKey(-1) + blockPrevHash(-1) + blockGasReward(-1).toString() + blockTxs(-1)
        let liquidBlockHash = sha256(liquidBlock.toBytes()).toBase58String() # TODO Utf8 или toBase58? достаточно ли sha256? Попробовать blake и keccak

        WriteSet([
            # TODO везде не парсить разделители, а делать split()
            # TODO вместо available хранить reserved?
            DataEntry(keyAccountPrefix + minerAccount, pubKeyOf(minerAccount) + "," + regHeightOf(minerAccount).toString() + "," 
                + (totalBalanceOf(minerAccount) + blockGasReward(-1)).toString() + "," + (availableBalanceOf(minerAccount) + blockGasReward(-1)).toString())
            , DataEntry(h().toString(), liquidBlockHash + blockInfo(-1))
            , DataEntry(keyHeight, nextHeight)
            , DataEntry(keyBase, base() + 1) # TODO калибровать сложность (от высоты, на которой был смайнен прошлый блок). Какая скорость?
            # везде хранить не паблик кеи, а аккаунты
            # методы-конструкторы для аккаунта, блока, транзакции
            , DataEntry(keyLast, "," + nextHeight.toString() + "," + height.toString() + "," + toBase58String(i.callerPublicKey) + "," + liquidBlockHash + ",0")
        ])
}

@Callable(i)
func utxProcessing() = {
    if i.callerPublicKey != blockMinerPublicKey(-1).fromBase58String() then throw("Only the current miner can processing UTX!")
    else if getIntegerValue(this, keyUtxSize) == 0 then WriteSet([])
    else
        let utx = getStringValue(this, keyUtx)
        let utxSize = getIntegerValue(this, keyUtxSize)
        let marker = extract(indexOf(utx, ";"))
        let tx = take(utx, marker)

        let txSignature = take(tx, extract(indexOf(tx, ",")))
        let txSenderPublicKey = { let raw = drop(tx, txSignature.size() + 1); take(raw, extract(indexOf(raw, ","))) }
        let txGas = { let raw = drop(tx, txSignature.size() + txSenderPublicKey.size() + 2); take(raw, extract(indexOf(raw, ","))) }
        let txScript = drop(tx, txSignature.size() + txSenderPublicKey.size() + txGas.size() + 3)

        let txSenderAcc = extract(accountOf(txSenderPublicKey.toBytes()))
        let validation = validate(txSenderAcc, txGas.parseIntValue(), txScript, false)
        let costs = estimate(txScript)

        if validation.size() > 0 then 
            WriteSet([DataEntry(keyUtxSize, utxSize - 1), DataEntry(keyUtx, drop(utx, marker + 1))])
        else
            WriteSet(
                DataEntry(keyLast, "," + h().toString() + "," + blockReferenceHeight(-1).toString() + "," + blockMinerPublicKey(-1) + "," 
                    + blockPrevHash(-1) + "," + (blockGasReward(-1) + costs[0]).toString() + blockTxs(-1) + ";" + tx)
                ::DataEntry(keyUtxSize, utxSize - 1)
                ::DataEntry(keyUtx, drop(utx, marker + 1))
                ::evaluate(txScript)
                ::DataEntry( keyAccountPrefix + txSenderAcc, txSenderPublicKey + "," + regHeightOf(txSenderAcc).toString() + "," 
                    + (totalBalanceOf(txSenderAcc) - costs[0] - costs[1]).toString() + "," 
                    + (availableBalanceOf(txSenderAcc) + txGas.parseIntValue() - costs[0]).toString() )
                ::nil
            )
}

@Callable(i)
func transaction(signatureBase64: String, gas: Int, script: String) = {
    if i.caller == this then throw("The dApp can't send transactions!")
    else if !isRegistered(i.callerPublicKey) then throw("Only registered accounts can send transactions!")
    else if !(getIntegerValue(this, keyUtxSize) < utxLimit) then throw("UTX size limit reached! Please try later")
    else
        let txBody = extract(accountOf(i.callerPublicKey)) + "," + gas.toString() + "," + script
        let acc = extract(accountOf(i.callerPublicKey))
        let validation = validate(acc, gas, script, true)
        let costs = estimate(script)
        let reserved = costs[0] + costs[1]

        if validation.size() > 0 then throw(validation)
        else if !sigVerify(txBody.toBytes(), signatureBase64.fromBase64String(), i.callerPublicKey) then throw("Incorrect signature!")
        else
            let utxPool = getStringValue(this, keyUtx)
            WriteSet([
                DataEntry(keyUtx, utxPool + signatureBase64 + "," + txBody + ";"),
                DataEntry(keyUtxSize, getIntegerValue(this, keyUtxSize) + 1),
                DataEntry(keyAccountPrefix + acc, pubKeyOf(acc) + "," + regHeightOf(acc).toString() + "," + totalBalanceOf(acc).toString() + "," 
                    + (availableBalanceOf(acc) - reserved).toString())
            ])
}

@Verifier(tx)
func verify() = {
    #match tx {
    #    case d:DataTransaction => false # blockchain can be changed only via dApp actions
    #    case t:TransferTransaction => !isDefined(t.assetId) # TODO ведь так проверять на вавесность?
    #    # TODO для SetScript - мультисиг с китами в блокчейне
    #    case _ => sigVerify(tx.bodyBytes, tx.proofs[0], dappPublicKey)
    #}
    true
}
